{
  "name": "Webpack-summary",
  "tagline": "webpack的学习总结",
  "body": "# Webpack学习总结 #\r\nwebpack, 更优秀的前端模块依赖管理工具。\r\n\r\n## What is webpack ##\r\n### 网上介绍 ###\r\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\r\n![what is webpack](http://webpack.github.io/assets/what-is-webpack.png)\r\n\r\n### require ###\r\n模块依赖，一招搞定\r\n\r\n\trequire(\"./lib.js\");\r\n\trequire(\"./style.css\");\r\n\trequire(\"./style.less\");\r\n\trequire(\"./template.jade\");\r\n\trequire(\"./image.png\");\r\n\r\n在 Webpack 当中, 所有的资源都被当作是模块。\r\n\r\n### 加载器 ###\r\n对应各种不同文件类型的资源，Webpack有对应的模块loader\r\n\r\n\tmodule: {\r\n\t\t//加载器配置\r\n\t\tloaders: [\r\n\t\t\t//.css 文件使用 style-loader 和 css-loader 来处理\r\n\t\t\t{ test: /\\.css$/, loader: 'style-loader!css-loader' },\r\n\t\t\t//.js 文件使用 jsx-loader 来编译处理\r\n\t\t\t{ test: /\\.js$/, loader: 'jsx-loader?harmony' },\r\n\t\t\t//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理\r\n\t\t\t{ test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\r\n\t\t\t//图片文件使用 url-loader 来处理，小于8kb的直接转为base64\r\n\t\t\t{ test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\r\n\t\t]\r\n\t}\r\n\r\n## webpack的优势 ##\r\n1. webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移\r\n2. 所有静态资源都可以被当成模块引用，而不仅仅是JS了\r\n3. 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等\r\n4. 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮\r\n\r\n以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：\r\n\r\n\tdefine(['package/lib'], function(lib){\r\n\t\tfunction foo(){\r\n\t\t\tlib.log('hello world!');\r\n\t\t} \r\n\t\treturn {\r\n\t\t\tfoo: foo\r\n\t\t};\r\n\t});\r\n\r\n另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：\r\n\r\n\tdefine(function (require, exports, module){\r\n\t\tvar module1 = require(\"module1\");\r\n\t\tvar module2 = require(\"module2\");    \r\n\t \r\n\t\tmodule1.sayHello();\r\n\t\tmodule2.sayHi();\r\n\t \r\n\t\texports.helloWorld = function (){\r\n\t\t\tmodule1.sayHello();\r\n\t\t\tmodule2.sayHi();\r\n\t\t};\r\n\t});\r\n\r\n然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：\r\n\r\n\tvar module1 = require(\"module1\");\r\n\tvar module2 = require(\"module2\");    \r\n \r\n\tmodule1.sayHello();\r\n\tmodule2.sayHi();\r\n \r\n\texports.helloWorld = function (){\r\n\t\tmodule1.sayHello();\r\n\t\tmodule2.sayHi();\r\n\t};\r\n\r\n不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。\r\n\r\n## 安装使用 ##\r\n### 安装webpack ##\r\n首先确保机子上已安装node.js，然后通过npm安装webpack\r\n\r\n```$\r\nnpm install webpack -g\r\n```\r\n\r\n### 启动命令 ###\r\n\r\n切换到有 webpack.config.js 的目录然后运行\r\n\r\n```$\r\nwebpack     // 执行一次开发的编译\r\nwebpack -p  // 针对发布环境编译(压缩代码)\r\nwebpack -w  // 进行开发过程持续的增量编译(飞快地!)\r\nwebpack -d  // 生成map映射文件，告知哪些模块被最终打包到哪里了\r\nwebpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包\r\n```\r\n#### 插件的安装 ###\r\n所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用\r\n\r\n\tnpm install url-loader --save-dev\r\n\r\n如果目录没有package.json，则需要先init一下，再运行`npm install`命令\r\n\r\n\tnpm init\r\n\tnpm install url-loader --save-dev\r\n\r\n### 配置文件(webpack.config.js) ###\r\n每个项目下都必须配置有一个 webpack.config.js\r\n- plugins 插件项\r\n- entry 页面入口文件配置\r\n- output 对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里）\r\n- module.loaders 最关键的一块，配置每一种文件需要使用什么加载器来处理（多个loader之间用\"!\"连接）\r\n\r\n### 通用配置文件例子 ###\r\n\r\n\t// webpack.config.js\r\n\tvar webpack = require('webpack');\r\n\tvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin(/* chunkName= */'common', /* filename= */'common.js'); // 分析以下模块的共用代码, 单独打一个包到common.js\r\n\tvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); // 单独打包CSS\r\n\tvar HtmlWebpackPlugin = require('html-webpack-plugin'); // Html文件处理\r\n\t\r\n\tmodule.exports = {\r\n\t\tentry: {\r\n\t\t\tDetail: './modules/app/detail.js',\r\n\t\t\tHome: './modules/app/home.js'\r\n\t\t},\r\n\t\toutput: {\r\n\t\t\tpath: './build', // This is where images & js will go\r\n\t\t\t//publicPath: 'http://m.pp.cn/ppaweb/test/build/', // This is used to generate URLs to e.g. images\r\n\t\t\tpublicPath: '/ppaweb/example/build/', // This is used to generate URLs to e.g. images\r\n\t\t\tfilename: '[name].js',\r\n\t\t\tchunkFilename: \"[id].chunk.js?[hash:8]\"\r\n\t\t},\r\n\t\tplugins: [\r\n\t\t\tcommonsPlugin,\r\n\t\t\tnew ExtractTextPlugin('[name].css', {allChunks: true}), // 单独打包CSS\r\n\t\r\n\t\t\t// 全局变量\r\n\t\t\tnew webpack.DefinePlugin({\r\n\t\t\t\t//__DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV||'false')) //通过环境变量设置\r\n\t\t\t\t__DEV__: 'false' // 开发调试时把它改为true\r\n\t\t\t}),\r\n\t\r\n\t\t\t/**\r\n\t\t\t* HTML文件编译，自动引用JS/CSS\r\n\t\t\t* \r\n\t\t\t* filename - 输出文件名，相对路径output.path\r\n\t\t\t* template - HTML模板，相对配置文件目录\r\n\t\t\t* chunks - 只包含指定的文件（打包后输出的JS/CSS）,不指定的话，它会包含生成的所有js和css文件\r\n\t\t\t* excludeChunks - 排除指定的文件（打包后输出的JS/CSS），比如：excludeChunks: ['dev-helper']\r\n\t\t\t* hash\r\n\t\t\t*/\r\n\t\t\tnew HtmlWebpackPlugin({filename: 'views/home.html', template: 'views/home.html', chunks: ['common', 'Home'], hash: true}),\r\n\t\t\tnew HtmlWebpackPlugin({filename: 'views/detail.html', template: 'views/detail.html', chunks: ['common', 'Detail'], hash: true})\r\n\t\t],\r\n\t\r\n\t\tmodule: {\r\n\t\t\tloaders: [\r\n\t\t\t\t{\r\n\t\t\t\t\ttest: /\\.js$/, loader: 'babel-loader', // ES6\r\n\t\t\t\t\texclude: /(node_modules|bower_components|ppaweb\\\\libs\\\\webpack)/\r\n\t\t\t\t},\r\n\t\t\t\t// CSS,LESS打包进JS\r\n\t\t\t\t{ test: /\\.css$/, loader: 'style-loader!css-loader' },\r\n\t\t\t\t{ test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' }, // use ! to chain loaders\r\n\t\t\t\t// CSS,LESS单独打包\r\n\t\t\t\t//{ test: /\\.css$/, loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\") },\r\n\t\t\t\t//{ test: /\\.less$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader') },\r\n\t\t\r\n\t\t\t\t{ test: /\\.tpl$/, loader: 'ejs'}, // artTemplate/ejs 's tpl\r\n\t\t\t\t{\r\n\t\t\t\t\ttest: /\\.(png|jpg|gif)$/,\r\n\t\t\t\t\tloader: 'url-loader',\r\n\t\t\t\t\tquery: {\r\n\t\t\t\t\t\tname: '[path][name].[ext]?[hash:8]',\r\n\t\t\t\t\t\tlimit: 8192 // inline base64 URLs for <=8k images, direct URLs for the rest\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t},\r\n\t\tresolve: {\r\n\t\t\talias: {\r\n\t\t\t\t'lib0': '../../../ppaweb/libs/webpack', // 从module调用webpack上的公共lib库路径简写\r\n\t\t\t\t'lib1': '../../../../ppaweb/libs/webpack', // 从module的子文件夹调用webpack上的公共lib库路径简写\r\n\t\t\t\t'lib2': '../../../../../ppaweb/libs/webpack' // 从module的两层子文件夹调用webpack上的公共lib库路径简写\r\n\t\t\t},\r\n\t\t\t// 现在可以写 require('file') 代替 require('file.coffee')\r\n\t\t\textensions: ['', '.js', '.json', '.coffee']\r\n\t\t}\r\n\t};\r\n\r\n具体可以参考：[webpack-demo的配置项](https://github.com/diamont1001/webpack-demo/blob/master/example1/webpack.config.js)\r\n\r\n## Webpack常用功能 ##\r\n### JS里:CSS及图片引用 ###\r\n\r\n\trequire('./bootstrap.css');\r\n\trequire('./myapp.less');\r\n\t\r\n\tvar img = document.createElement('img');\r\n\timg.src = require('./glyph.png');\r\n\r\n- Synchronous\r\n- CSS和LESS会被打包到JS\r\n- 图片可能被转化成 base64 格式的 dataUrl\r\n\r\n```\r\nmodule: {\r\n\tloaders: [\r\n\t\t//图片文件使用 url-loader 来处理，小于8kb的直接转为base64\r\n\t\t{ test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\r\n\t]\r\n}\r\n```\r\n\r\n### LESS/CSS里:图片引用 ###\r\n\r\n\tbackground-image: url(\"./logo.png\");\r\n\r\n根据配置“url-loader?limit=xxx”来决定把图片转换成base64还是图片链接形式引用。\r\n\r\n\tmodule: {\r\n\t\tloaders: [\r\n\t\t\t//图片文件使用 url-loader 来处理，小于8kb的直接转为base64\r\n\t\t\t{ test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\r\n\t\t]\r\n\t}\r\n\r\n### LESS/CSS里：@ import 路径问题 ###\r\nLESS里可以通过`@import mixin.less`进行模块化开发，可以在import的路径前面加上~，表示路径以模块处理，支持alias。\r\n\r\n`tnpm i @ali/pp-libs --save-dev`\r\n\r\n```\r\n# index.less\r\n@import '@ali/pp-libs/libs/base/reset.less';\r\n```\r\n\r\n### CSS能单独打包 ###\r\n有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 `extract-text-webpack-plugin` 来帮忙。\r\n\r\n只需两步：\r\n\r\n1. 插件安装\r\n\r\n`npm install extract-text-webpack-plugin --save-dev`\r\n\r\n2. 配置文件webpack.config.js\r\n\r\n```\r\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\r\n\r\n……\r\n\r\nplugins: [\r\n\t// 目标文件名规则[name].css\r\n\tnew ExtractTextPlugin('[name].css', {allChunks: true})\r\n],\r\nmodule: {\r\n\tloaders: [\r\n\t\t{ test: /\\.css$/, loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\") },\r\n\t\t{ test: /\\.less$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader') },\r\n\t]\r\n},\r\n```\r\n\r\n### 公共代码自动抽离 ###\r\n提取多个页面之间的公共模块，并将该模块打包为 common.js\r\n\r\n`A.js, B.js => a.js, b.js, common.js`\r\n\r\n    // 分析以下模块的共用代码, 单独打一个包到common.js\r\n\tvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin(/*chunkName=*/'common', /*filename=*/'common.js');\r\n\t\r\n\tplugins: [\r\n\t\tcommonsPlugin\r\n\t],\r\n\r\n记得要在HTML手动引入common.js\r\n\r\n### 自定义公共模块提取 ###\r\n上面是自动在所有入口的js中提取公共代码，并打包为common.js。\r\n\r\n有时候我们希望能更加个性化一些，比如我希望:\r\n\r\n`A.js+C.js => AC-common.js`\r\n\r\n`B.js+D.js => BD-common.js`\r\n\r\n我们可以这样配：\r\n\r\n```\r\nmodule.exports = {\r\n\tentry: {\r\n\t\tA: \"./a.js\",\r\n\t\tB: \"./b.js\",\r\n\t\tC: \"./c.js\",\r\n\t\tD: \"./d.js\",\r\n\t\tE: \"./e.js\"\r\n\t},\r\n\toutput: {\r\n\t\tfilename: \"[name].js\"\r\n\t\t},\r\n\tplugins: [\r\n\t\tnew CommonsChunkPlugin(\"AC-commons.js\", [\"A\", \"C\"]),\r\n\t\tnew CommonsChunkPlugin(\"BD-commons.js\", [\"B\", \"D\"])\r\n\t]\r\n};\r\n\r\n// <script>s required:\r\n// a.html: AC-commons.js, A.js\r\n// b.html: BD-commons.js, B.js\r\n// c.html: AC-commons.js, C.js\r\n// d.html: BD-commons.js, D.js\r\n// e.html: E.js\r\n```\r\n\r\n### HTML自动引用 JS/CSS ###\r\n有时候我们连HTML里的JS/CSS资源都懒的写，也是可行的，HTML也可以当成模块来写。\r\n\r\n`npm install html-webpack-plugin --save-dev`\r\n\r\n```\r\nvar HtmlWebpackPlugin = require('html-webpack-plugin'); // Html文件处理\r\n\r\nmodule.exports = {\r\n\r\n\t……\r\n\r\n\tplugins: [\r\n\t\t/**\r\n\t\t* HTML文件编译，自动引用JS/CSS\r\n\t\t* \r\n\t\t* filename - 输出文件名，相对路径output.path\r\n\t\t* template - HTML模板，相对配置文件目录\r\n\t\t* chunks - 只包含指定的文件（打包后输出的JS/CSS）,不指定的话，它会包含生成的所有js和css文件\r\n\t\t* excludeChunks - 排除指定的文件（打包后输出的JS/CSS），比如：excludeChunks: ['dev-helper']\r\n\t\t* hash\r\n\t\t*/\r\n\t\tnew HtmlWebpackPlugin({filename: 'views/list.html', template: 'src/modules/app/list/index.html', chunks: ['common', 'List'], hash: true}),\r\n\t\tnew HtmlWebpackPlugin({filename: 'views/detail.html', template: 'src/modules/app/detail/index.html', chunks: ['common', 'Detail'], hash: true})\r\n\t],\r\n};\r\n```\r\n\r\n具体参考 [webpack-demo的配置项](https://github.com/diamont1001/webpack-demo/blob/master/example1/webpack.config.js)\r\n\r\n### 全局变量 ###\r\n有些代码我们只想在开发环境使用（比如log），这里，我们需要用到全局变量插件：webpack.DefinePlugin\r\n\r\n```\r\nmodule.exports = {\r\n\tplugins: [\r\n\t\t// 全局变量\r\n\t\tnew webpack.DefinePlugin({\r\n\t\t\t// __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false')), //通过环境变量设置\r\n\t\t\t__DEV__: JSON.stringify(JSON.parse('true')), // 开发调试时把它改为true\r\n\t\t\t__HELLO__: JSON.stringify('hello world')\r\n\t\t})\r\n\t]\r\n};\r\n```\r\n\r\njs中调用\r\n\r\n```\r\nif(__DEV__) {\r\n\tconsole.log(__HELLO__);\r\n}\r\n```\r\n\r\n注意：webpack -p 会执行 uglify dead-code elimination, 任何这种代码都会被剔除, 所以你不用担心秘密功能泄漏.\r\n\r\n### 异步加载 ###\r\n\r\n`require.ensure`\r\n\r\n语法：\r\n```\r\nrequire.ensure(dependencies: String[],\r\n\t\tcallback: function([require]),\r\n\t\t[chunkName: String])\r\n```\r\n\r\n与require AMD类似，也是在需要的时候才会加载相应的模块。但不同的是，require.ensure在模块被下载下来后（模块还没被执行）便立即执行回调函数.\r\n另外require.ensure可以指定构建后chunk名，如果之前已有require.ensure指定了该名称，webpack会将这些模块统一合并到一个模块集里。\r\n\r\n简单例子\r\n\r\n\t// 异步加载\r\n\tif(i < 0) {\r\n\t\trequire.ensure([], function() {\r\n\t\t\trequire('a.js');\r\n\t\t});\r\n\t}\r\n\r\n定义异步加载文件名字(webpack.config.js)\r\n\r\n\toutput: {\r\n\t\tchunkFilename: \"[id].chunk.[hash:8].js\"\r\n\t},\r\n\r\n生成的异步文件引用逻辑自动包含在源目标JS中，不用手动引用，所以以上文件名随便怎么定义都不影响。\r\n\r\n![](https://github.com/diamont1001/webpack-summary/blob/master/imgs/require.ensure-demo.png?raw=true)\r\n\r\n### file-loader ###\r\n图片加载器url-loader其实是对file-loader的一个封装\r\n\r\n```\r\nloaders: [\r\n\t{\r\n\t\ttest: /\\.(png|jpg|gif)$/,\r\n\t\tloader: 'url-loader',\r\n\t\tquery: {\r\n\t\t\tname: '[path][name].[ext]?[hash:8]',\r\n\t\t\tlimit: 8192\r\n\t\t}\r\n\t}\r\n]\r\n```\r\n\r\n如果文件超出体积, 就给一个这样规则的文件名\r\n![](https://github.com/diamont1001/webpack-summary/blob/master/imgs/file-loader-demo.png?raw=true)\r\n\r\n参考：[https://github.com/webpack/file-loader](https://github.com/webpack/file-loader)\r\n\r\n### ES6支持 ###\r\n\r\n\tmodule: {\r\n\t\tloaders: [\r\n\t\t\t{\r\n\t\t\t\ttest: /\\.js$/, loader: 'babel-loader', // ES6\r\n\t\t\t\texclude: /(node_modules|bower_components|ppaweb\\\\libs\\\\webpack)/\r\n\t\t\t},\r\n\t\t]\r\n\t},\r\n\r\n参考：[http://npm.taobao.org/package/babel-loader](http://npm.taobao.org/package/babel-loader)\r\n\r\n### Alias:项目迁移更方便 ###\r\nwebpack允许配置路径的别名，这样在一些外部资源的依赖的时候显得格外有用，对以后的项目迁移等都起到不小的作用。\r\n\r\n\tresolve: {\r\n\t\talias: {\r\n\t\t\t// 从module调用公共libs上的库路径简写\r\n\t\t\t'lib0': '../../../libs',\r\n\t\r\n\t\t\t// 从module的子文件夹调用公共libs上的库路径简写\r\n\t\t\t'lib1': '../../../../libs', \r\n\t\r\n\t\t\t// 从module的两层子文件夹调用公共libs上的库路径简写\r\n\t\t\t'lib2': '../../../../../libs' \r\n\t\t}\r\n\t}\r\n\r\n```\r\n# module/index.js\r\nrequire('lib0/proxy');\r\n\r\n# module/app/index.js\r\nrequire('lib1/proxy');\r\n\r\n# module/app/header/index.js\r\nrequire('lib2/proxy');\r\n```\r\n\r\n### shimming ###\r\n在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 [exports-loader](https://github.com/webpack/exports-loader) 来帮忙：\r\n\r\n\t{ test: require.resolve(\"./src/js/tool/swipe.js\"),  loader: \"exports?swipe\"}\r\n\r\n之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：\r\n\r\n\trequire('./tool/swipe.js');\r\n\tswipe(); \r\n\r\n## Webpack模块编写 ##\r\n### 模块框架 ###\r\n\r\n\t// var $ = require('zepto');\r\n\t// require('./index.less');\r\n\r\n\t!(function () {\r\n\t\r\n\t\tvar module1 = (function () {\r\n\t\t\tvar _e = {};\r\n\t\t\r\n\t\t\t_e.test = function () {\r\n\t\t\t\t// do something here\r\n\t\t\t};\r\n\t\t\r\n\t\t\treturn _e;\r\n\t\t})();\r\n\r\n\t\twindow.module1 = module1;\r\n\t\t\r\n\t\ttry {\r\n\t\t\tmodule.exports = module1;\r\n\t\t} catch (e) {}\r\n\r\n\t})();\r\n\t\r\n### 模块/组件打包 ###\r\n\r\n模块/组件一般会发布到NPM或者其他地方提供给他人使用的，这里可以使用libraryTarget字段来控制webpack打包后输出为模块/组件。\r\n\r\n```js\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n    entry: {\r\n        pca: './src/main.js'\r\n    },\r\n    output: {\r\n        path: './dist',\r\n        filename: '[name].js',\r\n        libraryTarget: \"umd\" // 组件采用UMD格式打包\r\n    },\r\n\r\n    module: {\r\n        loaders: [\r\n            {\r\n                test: /\\.js$/, loader: 'babel-loader',\r\n                exclude: /(node_modules|libs)/\r\n            }\r\n        ]\r\n    }\r\n};\r\n```\r\n\r\n这样，打包后发布到npm，别人就可以直接 `npm install xxx` 来安装后，可以 `var a = require('xxx');` 来使用了。\r\n\r\n## 旧项目迁移方案 ##\r\n### 1. 入口文件 ###\r\n一般一个页面(HTML)对应一个入口文件\r\n\r\n\t/views/a.html\r\n\t/views/b.html\r\n\t/views/c.html\r\n\r\n\tentry: {\r\n\t\tA: 'modules/app/a.js',\r\n\t\tB: 'modules/app/b.js',\r\n\t\tC: 'modules/app/c.js'\r\n\t}\r\n\r\n### 2. 文件引用 ###\r\n![](https://github.com/diamont1001/webpack-summary/blob/master/imgs/1.png?raw=true)\r\n\r\n![](https://github.com/diamont1001/webpack-summary/blob/master/imgs/2.png?raw=true)\r\n\r\n### 3. 优化 ###\r\n- common.js\r\n- css单独打包\r\n- 异步加载\r\n- HTML模板（html-webpack-plugin）\r\n\r\n## 附录 ##\r\n- [Git官网](https://webpack.github.io/)\r\n- [入门指引（含例子webpack+react）](https://github.com/petehunt/webpack-howto)\r\n- [webpack简易教程PPT](http://slides.com/diamont1001/webpack)\r\n- [webpack开发原型demo](https://github.com/diamont1001/webpack-demo)\r\n\r\n## Q&A ##\r\n###Q. HTML里引用JS能自动生成访问后缀吗？比如a.js?2016###\r\nA. 插件html-webpack-plugin\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}