<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Webpack-summary by diamont1001</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Webpack-summary</h1>
      <h2 class="project-tagline">webpack的学习总结</h2>
      <a href="https://github.com/diamont1001/webpack-summary" class="btn">View on GitHub</a>
      <a href="https://github.com/diamont1001/webpack-summary/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/diamont1001/webpack-summary/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="webpack学习总结" class="anchor" href="#webpack%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Webpack学习总结</h1>

<p>webpack, 更优秀的前端模块依赖管理工具。</p>

<h2>
<a id="what-is-webpack" class="anchor" href="#what-is-webpack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is webpack</h2>

<h3>
<a id="网上介绍" class="anchor" href="#%E7%BD%91%E4%B8%8A%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>网上介绍</h3>

<p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。
<img src="http://webpack.github.io/assets/what-is-webpack.png" alt="what is webpack"></p>

<h3>
<a id="require" class="anchor" href="#require" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>require</h3>

<p>模块依赖，一招搞定</p>

<pre><code>require("./lib.js");
require("./style.css");
require("./style.less");
require("./template.jade");
require("./image.png");
</code></pre>

<p>在 Webpack 当中, 所有的资源都被当作是模块。</p>

<h3>
<a id="加载器" class="anchor" href="#%E5%8A%A0%E8%BD%BD%E5%99%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>加载器</h3>

<p>对应各种不同文件类型的资源，Webpack有对应的模块loader</p>

<pre><code>module: {
    //加载器配置
    loaders: [
        //.css 文件使用 style-loader 和 css-loader 来处理
        { test: /\.css$/, loader: 'style-loader!css-loader' },
        //.js 文件使用 jsx-loader 来编译处理
        { test: /\.js$/, loader: 'jsx-loader?harmony' },
        //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理
        { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
        //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
        { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
    ]
}
</code></pre>

<h2>
<a id="webpack的优势" class="anchor" href="#webpack%E7%9A%84%E4%BC%98%E5%8A%BF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>webpack的优势</h2>

<ol>
<li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移</li>
<li>所有静态资源都可以被当成模块引用，而不仅仅是JS了</li>
<li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等</li>
<li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮</li>
</ol>

<p>以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：</p>

<pre><code>define(['package/lib'], function(lib){
    function foo(){
        lib.log('hello world!');
    } 
    return {
        foo: foo
    };
});
</code></pre>

<p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：</p>

<pre><code>define(function (require, exports, module){
    var module1 = require("module1");
    var module2 = require("module2");    

    module1.sayHello();
    module2.sayHi();

    exports.helloWorld = function (){
        module1.sayHello();
        module2.sayHi();
    };
});
</code></pre>

<p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：</p>

<pre><code>var module1 = require("module1");
var module2 = require("module2");    

module1.sayHello();
module2.sayHi();

exports.helloWorld = function (){
    module1.sayHello();
    module2.sayHi();
};
</code></pre>

<p>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p>

<h2>
<a id="安装使用" class="anchor" href="#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>安装使用</h2>

<h3>
<a id="安装webpack" class="anchor" href="#%E5%AE%89%E8%A3%85webpack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>安装webpack</h3>

<p>首先确保机子上已安装node.js，然后通过npm安装webpack</p>

<pre lang="$"><code>npm install webpack -g
</code></pre>

<h3>
<a id="启动命令" class="anchor" href="#%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>启动命令</h3>

<p>切换到有 webpack.config.js 的目录然后运行</p>

<pre lang="$"><code>webpack     // 执行一次开发的编译
webpack -p  // 针对发布环境编译(压缩代码)
webpack -w  // 进行开发过程持续的增量编译(飞快地!)
webpack -d  // 生成map映射文件，告知哪些模块被最终打包到哪里了
webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
</code></pre>

<h4>
<a id="插件的安装" class="anchor" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>插件的安装</h4>

<p>所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用</p>

<pre><code>npm install url-loader --save-dev
</code></pre>

<p>如果目录没有package.json，则需要先init一下，再运行<code>npm install</code>命令</p>

<pre><code>npm init
npm install url-loader --save-dev
</code></pre>

<h3>
<a id="配置文件webpackconfigjs" class="anchor" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6webpackconfigjs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>配置文件(webpack.config.js)</h3>

<p>每个项目下都必须配置有一个 webpack.config.js</p>

<ul>
<li>plugins 插件项</li>
<li>entry 页面入口文件配置</li>
<li>output 对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里）</li>
<li>module.loaders 最关键的一块，配置每一种文件需要使用什么加载器来处理（多个loader之间用"!"连接）</li>
</ul>

<h3>
<a id="通用配置文件例子" class="anchor" href="#%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BE%8B%E5%AD%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>通用配置文件例子</h3>

<pre><code>// webpack.config.js
var webpack = require('webpack');
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(/* chunkName= */'common', /* filename= */'common.js'); // 分析以下模块的共用代码, 单独打一个包到common.js
var ExtractTextPlugin = require("extract-text-webpack-plugin"); // 单独打包CSS
var HtmlWebpackPlugin = require('html-webpack-plugin'); // Html文件处理

module.exports = {
    entry: {
        Detail: './modules/app/detail.js',
        Home: './modules/app/home.js'
    },
    output: {
        path: './build', // This is where images &amp; js will go
        //publicPath: 'http://m.pp.cn/ppaweb/test/build/', // This is used to generate URLs to e.g. images
        publicPath: '/ppaweb/example/build/', // This is used to generate URLs to e.g. images
        filename: '[name].js',
        chunkFilename: "[id].chunk.js?[hash:8]"
    },
    plugins: [
        commonsPlugin,
        new ExtractTextPlugin('[name].css', {allChunks: true}), // 单独打包CSS

        // 全局变量
        new webpack.DefinePlugin({
            //__DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV||'false')) //通过环境变量设置
            __DEV__: 'false' // 开发调试时把它改为true
        }),

        /**
        * HTML文件编译，自动引用JS/CSS
        * 
        * filename - 输出文件名，相对路径output.path
        * template - HTML模板，相对配置文件目录
        * chunks - 只包含指定的文件（打包后输出的JS/CSS）,不指定的话，它会包含生成的所有js和css文件
        * excludeChunks - 排除指定的文件（打包后输出的JS/CSS），比如：excludeChunks: ['dev-helper']
        * hash
        */
        new HtmlWebpackPlugin({filename: 'views/home.html', template: 'views/home.html', chunks: ['common', 'Home'], hash: true}),
        new HtmlWebpackPlugin({filename: 'views/detail.html', template: 'views/detail.html', chunks: ['common', 'Detail'], hash: true})
    ],

    module: {
        loaders: [
            {
                test: /\.js$/, loader: 'babel-loader', // ES6
                exclude: /(node_modules|bower_components|ppaweb\\libs\\webpack)/
            },
            // CSS,LESS打包进JS
            { test: /\.css$/, loader: 'style-loader!css-loader' },
            { test: /\.less$/, loader: 'style-loader!css-loader!less-loader' }, // use ! to chain loaders
            // CSS,LESS单独打包
            //{ test: /\.css$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader") },
            //{ test: /\.less$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader') },

            { test: /\.tpl$/, loader: 'ejs'}, // artTemplate/ejs 's tpl
            {
                test: /\.(png|jpg|gif)$/,
                loader: 'url-loader',
                query: {
                    name: '[path][name].[ext]?[hash:8]',
                    limit: 8192 // inline base64 URLs for &lt;=8k images, direct URLs for the rest
                }
            }
        ]
    },
    resolve: {
        alias: {
            'lib0': '../../../ppaweb/libs/webpack', // 从module调用webpack上的公共lib库路径简写
            'lib1': '../../../../ppaweb/libs/webpack', // 从module的子文件夹调用webpack上的公共lib库路径简写
            'lib2': '../../../../../ppaweb/libs/webpack' // 从module的两层子文件夹调用webpack上的公共lib库路径简写
        },
        // 现在可以写 require('file') 代替 require('file.coffee')
        extensions: ['', '.js', '.json', '.coffee']
    }
};
</code></pre>

<p>具体可以参考：<a href="https://github.com/diamont1001/webpack-demo/blob/master/example1/webpack.config.js">webpack-demo的配置项</a></p>

<h2>
<a id="webpack常用功能" class="anchor" href="#webpack%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Webpack常用功能</h2>

<h3>
<a id="js里css及图片引用" class="anchor" href="#js%E9%87%8Ccss%E5%8F%8A%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JS里:CSS及图片引用</h3>

<pre><code>require('./bootstrap.css');
require('./myapp.less');

var img = document.createElement('img');
img.src = require('./glyph.png');
</code></pre>

<ul>
<li>Synchronous</li>
<li>CSS和LESS会被打包到JS</li>
<li>图片可能被转化成 base64 格式的 dataUrl</li>
</ul>

<pre><code>module: {
    loaders: [
        //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
        { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
    ]
}
</code></pre>

<h3>
<a id="lesscss里图片引用" class="anchor" href="#lesscss%E9%87%8C%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LESS/CSS里:图片引用</h3>

<pre><code>background-image: url("./logo.png");
</code></pre>

<p>根据配置“url-loader?limit=xxx”来决定把图片转换成base64还是图片链接形式引用。</p>

<pre><code>module: {
    loaders: [
        //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
        { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
    ]
}
</code></pre>

<h3>
<a id="lesscss里-import-路径问题" class="anchor" href="#lesscss%E9%87%8C-import-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LESS/CSS里：@ import 路径问题</h3>

<p>LESS里可以通过<code>@import mixin.less</code>进行模块化开发，可以在import的路径前面加上~，表示路径以模块处理，支持alias。</p>

<p><code>tnpm i @ali/pp-libs --save-dev</code></p>

<pre><code># index.less
@import '@ali/pp-libs/libs/base/reset.less';
</code></pre>

<h3>
<a id="css能单独打包" class="anchor" href="#css%E8%83%BD%E5%8D%95%E7%8B%AC%E6%89%93%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CSS能单独打包</h3>

<p>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以标签引入。这时候我们需要 <code>extract-text-webpack-plugin</code> 来帮忙。</p>

<p>只需两步：</p>

<ol>
<li>插件安装</li>
</ol>

<p><code>npm install extract-text-webpack-plugin --save-dev</code></p>

<ol>
<li>配置文件webpack.config.js</li>
</ol>

<pre><code>var ExtractTextPlugin = require("extract-text-webpack-plugin");

……

plugins: [
    // 目标文件名规则[name].css
    new ExtractTextPlugin('[name].css', {allChunks: true})
],
module: {
    loaders: [
        { test: /\.css$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader") },
        { test: /\.less$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader') },
    ]
},
</code></pre>

<h3>
<a id="公共代码自动抽离" class="anchor" href="#%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%8A%BD%E7%A6%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>公共代码自动抽离</h3>

<p>提取多个页面之间的公共模块，并将该模块打包为 common.js</p>

<p><code>A.js, B.js =&gt; a.js, b.js, common.js</code></p>

<pre><code>// 分析以下模块的共用代码, 单独打一个包到common.js
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(/*chunkName=*/'common', /*filename=*/'common.js');

plugins: [
    commonsPlugin
],
</code></pre>

<p>记得要在HTML手动引入common.js</p>

<h3>
<a id="自定义公共模块提取" class="anchor" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%AC%E5%85%B1%E6%A8%A1%E5%9D%97%E6%8F%90%E5%8F%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>自定义公共模块提取</h3>

<p>上面是自动在所有入口的js中提取公共代码，并打包为common.js。</p>

<p>有时候我们希望能更加个性化一些，比如我希望:</p>

<p><code>A.js+C.js =&gt; AC-common.js</code></p>

<p><code>B.js+D.js =&gt; BD-common.js</code></p>

<p>我们可以这样配：</p>

<pre><code>module.exports = {
    entry: {
        A: "./a.js",
        B: "./b.js",
        C: "./c.js",
        D: "./d.js",
        E: "./e.js"
    },
    output: {
        filename: "[name].js"
        },
    plugins: [
        new CommonsChunkPlugin("AC-commons.js", ["A", "C"]),
        new CommonsChunkPlugin("BD-commons.js", ["B", "D"])
    ]
};

// &lt;script&gt;s required:
// a.html: AC-commons.js, A.js
// b.html: BD-commons.js, B.js
// c.html: AC-commons.js, C.js
// d.html: BD-commons.js, D.js
// e.html: E.js
</code></pre>

<h3>
<a id="html自动引用-jscss" class="anchor" href="#html%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8-jscss" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HTML自动引用 JS/CSS</h3>

<p>有时候我们连HTML里的JS/CSS资源都懒的写，也是可行的，HTML也可以当成模块来写。</p>

<p><code>npm install html-webpack-plugin --save-dev</code></p>

<pre><code>var HtmlWebpackPlugin = require('html-webpack-plugin'); // Html文件处理

module.exports = {

    ……

    plugins: [
        /**
        * HTML文件编译，自动引用JS/CSS
        * 
        * filename - 输出文件名，相对路径output.path
        * template - HTML模板，相对配置文件目录
        * chunks - 只包含指定的文件（打包后输出的JS/CSS）,不指定的话，它会包含生成的所有js和css文件
        * excludeChunks - 排除指定的文件（打包后输出的JS/CSS），比如：excludeChunks: ['dev-helper']
        * hash
        */
        new HtmlWebpackPlugin({filename: 'views/list.html', template: 'src/modules/app/list/index.html', chunks: ['common', 'List'], hash: true}),
        new HtmlWebpackPlugin({filename: 'views/detail.html', template: 'src/modules/app/detail/index.html', chunks: ['common', 'Detail'], hash: true})
    ],
};
</code></pre>

<p>具体参考 <a href="https://github.com/diamont1001/webpack-demo/blob/master/example1/webpack.config.js">webpack-demo的配置项</a></p>

<h3>
<a id="全局变量" class="anchor" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>全局变量</h3>

<p>有些代码我们只想在开发环境使用（比如log），这里，我们需要用到全局变量插件：webpack.DefinePlugin</p>

<pre><code>module.exports = {
    plugins: [
        // 全局变量
        new webpack.DefinePlugin({
            // __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false')), //通过环境变量设置
            __DEV__: JSON.stringify(JSON.parse('true')), // 开发调试时把它改为true
            __HELLO__: JSON.stringify('hello world')
        })
    ]
};
</code></pre>

<p>js中调用</p>

<pre><code>if(__DEV__) {
    console.log(__HELLO__);
}
</code></pre>

<p>注意：webpack -p 会执行 uglify dead-code elimination, 任何这种代码都会被剔除, 所以你不用担心秘密功能泄漏.</p>

<h3>
<a id="异步加载" class="anchor" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>异步加载</h3>

<p><code>require.ensure</code></p>

<p>语法：</p>

<pre><code>require.ensure(dependencies: String[],
        callback: function([require]),
        [chunkName: String])
</code></pre>

<p>与require AMD类似，也是在需要的时候才会加载相应的模块。但不同的是，require.ensure在模块被下载下来后（模块还没被执行）便立即执行回调函数.
另外require.ensure可以指定构建后chunk名，如果之前已有require.ensure指定了该名称，webpack会将这些模块统一合并到一个模块集里。</p>

<p>简单例子</p>

<pre><code>// 异步加载
if(i &lt; 0) {
    require.ensure([], function() {
        require('a.js');
    });
}
</code></pre>

<p>定义异步加载文件名字(webpack.config.js)</p>

<pre><code>output: {
    chunkFilename: "[id].chunk.[hash:8].js"
},
</code></pre>

<p>生成的异步文件引用逻辑自动包含在源目标JS中，不用手动引用，所以以上文件名随便怎么定义都不影响。</p>

<p><img src="https://github.com/diamont1001/webpack-summary/blob/master/imgs/require.ensure-demo.png?raw=true" alt=""></p>

<h3>
<a id="file-loader" class="anchor" href="#file-loader" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>file-loader</h3>

<p>图片加载器url-loader其实是对file-loader的一个封装</p>

<pre><code>loaders: [
    {
        test: /\.(png|jpg|gif)$/,
        loader: 'url-loader',
        query: {
            name: '[path][name].[ext]?[hash:8]',
            limit: 8192
        }
    }
]
</code></pre>

<p>如果文件超出体积, 就给一个这样规则的文件名
<img src="https://github.com/diamont1001/webpack-summary/blob/master/imgs/file-loader-demo.png?raw=true" alt=""></p>

<p>参考：<a href="https://github.com/webpack/file-loader">https://github.com/webpack/file-loader</a></p>

<h3>
<a id="es6支持" class="anchor" href="#es6%E6%94%AF%E6%8C%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ES6支持</h3>

<pre><code>module: {
    loaders: [
        {
            test: /\.js$/, loader: 'babel-loader', // ES6
            exclude: /(node_modules|bower_components|ppaweb\\libs\\webpack)/
        },
    ]
},
</code></pre>

<p>参考：<a href="http://npm.taobao.org/package/babel-loader">http://npm.taobao.org/package/babel-loader</a></p>

<h3>
<a id="alias项目迁移更方便" class="anchor" href="#alias%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E6%9B%B4%E6%96%B9%E4%BE%BF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Alias:项目迁移更方便</h3>

<p>webpack允许配置路径的别名，这样在一些外部资源的依赖的时候显得格外有用，对以后的项目迁移等都起到不小的作用。</p>

<pre><code>resolve: {
    alias: {
        // 从module调用公共libs上的库路径简写
        'lib0': '../../../libs',

        // 从module的子文件夹调用公共libs上的库路径简写
        'lib1': '../../../../libs', 

        // 从module的两层子文件夹调用公共libs上的库路径简写
        'lib2': '../../../../../libs' 
    }
}
</code></pre>

<pre><code># module/index.js
require('lib0/proxy');

# module/app/index.js
require('lib1/proxy');

# module/app/header/index.js
require('lib2/proxy');
</code></pre>

<h3>
<a id="shimming" class="anchor" href="#shimming" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>shimming</h3>

<p>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 <a href="https://github.com/webpack/exports-loader">exports-loader</a> 来帮忙：</p>

<pre><code>{ test: require.resolve("./src/js/tool/swipe.js"),  loader: "exports?swipe"}
</code></pre>

<p>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：</p>

<pre><code>require('./tool/swipe.js');
swipe(); 
</code></pre>

<h2>
<a id="webpack模块编写" class="anchor" href="#webpack%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Webpack模块编写</h2>

<h3>
<a id="模块框架" class="anchor" href="#%E6%A8%A1%E5%9D%97%E6%A1%86%E6%9E%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>模块框架</h3>

<pre><code>// var $ = require('zepto');
// require('./index.less');

!(function () {

    var module1 = (function () {
        var _e = {};

        _e.test = function () {
            // do something here
        };

        return _e;
    })();

    window.module1 = module1;

    try {
        module.exports = module1;
    } catch (e) {}

})();
</code></pre>

<h3>
<a id="模块组件打包" class="anchor" href="#%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6%E6%89%93%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>模块/组件打包</h3>

<p>模块/组件一般会发布到NPM或者其他地方提供给他人使用的，这里可以使用libraryTarget字段来控制webpack打包后输出为模块/组件。</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// webpack.config.js</span>

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> {
    entry<span class="pl-k">:</span> {
        pca<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>./src/main.js<span class="pl-pds">'</span></span>
    },
    output<span class="pl-k">:</span> {
        path<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>./dist<span class="pl-pds">'</span></span>,
        filename<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>[name].js<span class="pl-pds">'</span></span>,
        libraryTarget<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>umd<span class="pl-pds">"</span></span> <span class="pl-c">// 组件采用UMD格式打包</span>
    },

    module<span class="pl-k">:</span> {
        loaders<span class="pl-k">:</span> [
            {
                test<span class="pl-k">:</span><span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-cce">\.</span>js<span class="pl-k">$</span><span class="pl-pds">/</span></span>, loader<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>babel-loader<span class="pl-pds">'</span></span>,
                exclude<span class="pl-k">:</span><span class="pl-sr"> <span class="pl-pds">/</span>(node_modules<span class="pl-k">|</span>libs)<span class="pl-pds">/</span></span>
            }
        ]
    }
};</pre></div>

<p>这样，打包后发布到npm，别人就可以直接 <code>npm install xxx</code> 来安装后，可以 <code>var a = require('xxx');</code> 来使用了。</p>

<h2>
<a id="旧项目迁移方案" class="anchor" href="#%E6%97%A7%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>旧项目迁移方案</h2>

<h3>
<a id="1-入口文件" class="anchor" href="#1-%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. 入口文件</h3>

<p>一般一个页面(HTML)对应一个入口文件</p>

<pre><code>/views/a.html
/views/b.html
/views/c.html

entry: {
    A: 'modules/app/a.js',
    B: 'modules/app/b.js',
    C: 'modules/app/c.js'
}
</code></pre>

<h3>
<a id="2-文件引用" class="anchor" href="#2-%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. 文件引用</h3>

<p><img src="https://github.com/diamont1001/webpack-summary/blob/master/imgs/1.png?raw=true" alt=""></p>

<p><img src="https://github.com/diamont1001/webpack-summary/blob/master/imgs/2.png?raw=true" alt=""></p>

<h3>
<a id="3-优化" class="anchor" href="#3-%E4%BC%98%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. 优化</h3>

<ul>
<li>common.js</li>
<li>css单独打包</li>
<li>异步加载</li>
<li>HTML模板（html-webpack-plugin）</li>
</ul>

<h2>
<a id="附录" class="anchor" href="#%E9%99%84%E5%BD%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>附录</h2>

<ul>
<li><a href="https://webpack.github.io/">Git官网</a></li>
<li><a href="https://github.com/petehunt/webpack-howto">入门指引（含例子webpack+react）</a></li>
<li><a href="http://slides.com/diamont1001/webpack">webpack简易教程PPT</a></li>
<li><a href="https://github.com/diamont1001/webpack-demo">webpack开发原型demo</a></li>
</ul>

<h2>
<a id="qa" class="anchor" href="#qa" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Q&amp;A</h2>

<h3>
<a id="q-html里引用js能自动生成访问后缀吗比如ajs2016" class="anchor" href="#q-html%E9%87%8C%E5%BC%95%E7%94%A8js%E8%83%BD%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E8%AE%BF%E9%97%AE%E5%90%8E%E7%BC%80%E5%90%97%E6%AF%94%E5%A6%82ajs2016" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Q. HTML里引用JS能自动生成访问后缀吗？比如a.js?2016</h3>

<p>A. 插件html-webpack-plugin</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/diamont1001/webpack-summary">Webpack-summary</a> is maintained by <a href="https://github.com/diamont1001">diamont1001</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
